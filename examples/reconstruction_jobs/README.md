Reconstruction jobs
===================

In this example we illustrate how to split up the evaluations needed
for a functional reconstruction into several jobs.  These can be run
in parallel on several unrelated machines and computing nodes.  This
approach is also useful for splitting evaluations into smaller batches
and save them to disk, such that one can avoid data loss in case of
crashes or system errors.

We suggest following this approachu when performing particurarly
changelling calculations, where a large number of evaluations is
needed and/or the evaluations themselves are very time consuming.


Contents
--------

It contains the following files:

- [define_graph.m](define_graph.m) defines the computational graph.
  This is used by the other files, but it is not supposed to be run
  directly.
- [compute_degrees.wl](compute_degrees.wl) computes and store
  information on the total and partial degrees of the output of the
  graph, so that it can be used to generate sample points.  It should
  be run first.
- [generate_points.wl](generate_points.wl) generates a list of points
  for performing the reconstruction.
- [evaluate_points.wl](evaluate_points.wl) evaluates a subset of a
  list of points.
- [reconstruct.wl](reconstruct.wl) attempts the analytic functional
  reconstruction with the available evaluations.


Example
-------

Here is an explicit example of how one may proceed for the
reconstruction.  We recommend following the instructions below as well
as reading the comments inside the files to be run.

- First, we must compute the degrees of the output.  This is done in
`compute_degrees.wl`, which can either be run from the Mathematica
front end, or from the command line with
```
  math -script compute_degrees.wl
```
  This will load the graph from `define_graph.m` and generate the file
  `degrees.fflow` with all the required information.

- Next, we want to generate a list of points to be evaluated.  In this
  example we start by assuming only one prime field will be needed.
  This is usually the best option, unless one already happens to know
  that one prime is not sufficient.  The list can be generated by
  running `generate_points.wl`, either from the command line with
```
  math -script generate_points.wl nprimes 1
```
  or from the Mathematica front end, setting `nprimes=1` at the
  beginning of the file.  This will create a file `points_1.fflow`
  which stores the points to be evaluated in binary format.  Notice
  that this step does not load the graph to be evaluated, but only the
  information about the degrees generated in the previous step and
  saved in the file `degrees.fflow`.

- We now must evaluate the generated list of points.  We can read how
  many points we generated from Mathematica using
```
  <<FiniteFlow`
  FFSamplesFileSize["points_1.fflow"]
```
  In this case, this tells us we generated 226 points.  We can now
  choose to evaluate any subset of them independently, even on
  different machines.  For this, the files `degrees.fflow` and
  `points_1.fflow` must be copied on the machines where we want to run
  the evaluations.  Let us split these into two batches of 113 points
  each.  These evaluations can be done by running
  `evaluate_points.wl`.  We run it for the first batch, either from
  the command line with
```
  math -script evaluate_points.wl file points_1.fflow start 0 npoints 113
```
  or from the Mathematica front end setting `file=points_1.fflow`,
  `start=0` and `npoints=113` at the beginning of the file.
  Similarly, for the second batch, we can run it from the command line
  with
```
  math -script evaluate_points.wl file points_1.fflow start 113 npoints 113
```
  or from the Mathematica front end setting `file=points_1.fflow`
  `start=113` and `npoints=113` at the beginning of the file.  As
  already stated, these two runs are completely independent, and can
  be performed either sequentially or in parallel, and possibly on
  different nodes or on different machines.  These will generate the
  files `evaluations_0_113_points_1.fflow` and
  `evaluations_113_113_points_1.fflow` respectively, with all the
  performed evaluations.  Of course, one can split up the evaluations
  even more in order to take advantage of available computing
  resources.

- We now attempt to reconstruct analytically the output of the graphs
  from the evaluations performed so far.  All the files
  `evaluations_*.fflow` we have must should be copied on the same
  machine where the reconstruction is attempted.  This is done in the
  file `reconstruct.wl`.  In this example, the reconstruction will
  fail at this stage, an return the value `FFMissingPrimes`,
  indicating that additional primes are needed for the reconstruction.

- We need to add more evaluation points.  Since one prime was not
  enough, we will now assume two primes are needed.  The list of
  points can be generated similarly as before, with obvious
  changes, e.g. from the command line with
```
  math -script generate_points.wl nprimes 2
```
  which generates the file `points_2.fflow`.  Notice that this script
  takes into account that some evaluations have alredy been performed,
  by loading them from the files `evaluations_*.fflow` already present
  in this directory.  Hence, only a complementary list of points, which
  have not been evaluated yet, is generated.

- We evaluate the new list of points similarly as before.  For
  instance, we can split the evaluations into two parts again, and
  perform them using
```
  math -script evaluate_points.wl file points_2.fflow start 0 npoints 113
```
  and
```
  math -script evaluate_points.wl file points_2.fflow start 113 npoints 113
```
  respectively, producing two more evaluation files.

- We run `reconstruct.wl` once again, and this time we successfuly
  reconstruct the analytic result.


Reset the example
-----------------

At any stage, you can clean the generated files and reset the example
using
```
rm *.fflow
```
in this directory.

